# MyJava

### This is my Learn Java way

  * SpringMVC + Mybatis整合测试，从数据库中读取数据展示到前台页面，数据库采用MySQL，Dao层使用逆向工程生成
  * B2CProject电商项目实践
    * 一个类似于JD、TB的分布式架构设计，包括后台管理系统、前台系统、单点登陆系统、搜索系统、会员系统，架构属于分布式架构，前台系统和单点登陆系统采用的是集群方式部署，在后台采用Maven的多模块化的管理分层开发，系统内部之间通讯采用MQ方式，使用Active MQ实现，部署方面采用Nginx+tomcat模式，一部分做反向代理，一部分做图片上传服务器
  * JavaBase（java基础）
    * 算法初学
        * 排序
            * 冒泡排序
            * 选择排序
            * 字符串的反转
            * 插入排序
    * dataType数据类型
        * 数据的自动装箱
        * String深入理解
            * String类初始化后是不可变的
            * String不一定创建对象
            * 使用new String 一定会创建对象
            * String.intern()
    * 多线程
        * 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）
        * 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）
        * 在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用
        * 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
        * 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 
        * 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。
        * 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。
        * Thread和Runnable的区别
            * 如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。
            * 总结：
                * 实现Runnable接口比继承Thread类所具有的优势：
                1. 适合多个相同的程序代码的线程去处理同一个资源
                2. 可以避免java中的单继承的限制
                3. 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
                4. 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</br>
        **main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。**</br>
        在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。
        * 常用函数
            * sleep(long millis):在指定的毫秒值内让当前正在执行的线程休眠（暂停执行）
            * join():等待t线程终止，join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。
            * yield():Thread.yield()暂停当前正在执行的线程对象，并且执行其他线程,yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会
                * yield()和sleep()区别：
                    1. sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。
                    2. sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程
                    3. 另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 
            * wait():Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。
            * wait()和slepp()区别：
                * 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 
                * wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 
                    *需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException*